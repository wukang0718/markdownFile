# 程序的机器级表示

**汇编代码**是机器代码的文本表示，给出程序的每一条指令

GCC调用`汇编器`和`链接器`，根据汇编代码生成可执行的机器代码

## 程序编码

### 机器级代码

计算机系统使用了多种不同形式的抽象，其中两种抽象尤为重要：

1. 第一种是由`指令集体系结构或指令集架构`来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响
2. 第二种抽象是：机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组

> 汇编代码表示非常接近于机器代码。与机器代码的二进制相比，汇编代码的主要特点是他用可读性更好的文本格式表示

> 能够理解汇编代码以及他与原始的C代码的联系，是理解计算机如何执行程序的关键一步

程序内存包括：

1. 程序的可执行机器代码
2. 操作系统需要的一些信息
3. 用户分配的内存块

操作系统负责管理虚拟地址控制，将虚拟地址翻译成实际处理器内存中的物理地址

**一条机器指令只执行一个非常基本的操作**

### 代码示例

mstore.c

```c
long mult2(long, long);

void multstore(long x, long y, long *dest)
{
  long t = mult2(x, y);
  *dest = t;
}
```

命令行执行

```shell
gcc -Og -S mstore.c
```

在 centos  上使用 `gcc 版本 10.2.0 (GCC` 编译生成的 mstore.s

```
	.file	"mstore.c"
	.text
	.globl	multstore
	.type	multstore, @function
multstore:
.LFB0:
	.cfi_startproc
	pushq	%rbx
	.cfi_def_cfa_offset 16
	.cfi_offset 3, -16
	movq	%rdx, %rbx
	call	mult2
	movq	%rax, (%rbx)
	popq	%rbx
	.cfi_def_cfa_offset 8
	ret
	.cfi_endproc
.LFE0:
	.size	multstore, .-multstore
	.ident	"GCC: (GNU) 10.2.0"
	.section	.note.GNU-stack,"",@progbits
```

> pushq	%rbx  指令表示应该将寄存器%rbx的内容压入程序栈中

**反汇编器：**查看机器代码文件的内容

```shell
objdump -d mstore.o
```

输入内容

```
mstore.o：     文件格式 elf64-x86-64
Disassembly of section .text:
0000000000000000 <multstore>:
   0:	53                   	push   %rbx
   1:	48 89 d3             	mov    %rdx,%rbx
   4:	e8 00 00 00 00       	callq  9 <multstore+0x9>
   9:	48 89 03             	mov    %rax,(%rbx)
   c:	5b                   	pop    %rbx
   d:	c3                   	retq
```

main.c

```c
#include <stdio.h>

void multstore(long, long, long *);

int main()
{
  long d;
  multstore(2, 3, &d);
  printf("2 * 3 ---> %ld\n", d);
  return 0;
}

long mult2(long a, long b)
{
  long s = a * b;
  return s;
}
```

命令行执行

```bash
gcc -Og -o prog main.c mstore.c
# 反汇编
objdump -d prog
```

输出

```
prog：     文件格式 elf64-x86-64


Disassembly of section .init:

00000000004003c8 <_init>:
  4003c8:	48 83 ec 08          	sub    $0x8,%rsp
  4003cc:	48 8b 05 25 0c 20 00 	mov    0x200c25(%rip),%rax        # 600ff8 <_DYNAMIC+0x1d0>
  4003d3:	48 85 c0             	test   %rax,%rax
  4003d6:	74 05                	je     4003dd <_init+0x15>
  4003d8:	e8 43 00 00 00       	callq  400420 <__gmon_start__@plt>
  4003dd:	48 83 c4 08          	add    $0x8,%rsp
  4003e1:	c3                   	retq

Disassembly of section .plt:

00000000004003f0 <printf@plt-0x10>:
  4003f0:	ff 35 12 0c 20 00    	pushq  0x200c12(%rip)        # 601008 <_GLOBAL_OFFSET_TABLE_+0x8>
  4003f6:	ff 25 14 0c 20 00    	jmpq   *0x200c14(%rip)        # 601010 <_GLOBAL_OFFSET_TABLE_+0x10>
  4003fc:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000400400 <printf@plt>:
  400400:	ff 25 12 0c 20 00    	jmpq   *0x200c12(%rip)        # 601018 <_GLOBAL_OFFSET_TABLE_+0x18>
  400406:	68 00 00 00 00       	pushq  $0x0
  40040b:	e9 e0 ff ff ff       	jmpq   4003f0 <_init+0x28>

0000000000400410 <__libc_start_main@plt>:
  400410:	ff 25 0a 0c 20 00    	jmpq   *0x200c0a(%rip)        # 601020 <_GLOBAL_OFFSET_TABLE_+0x20>
  400416:	68 01 00 00 00       	pushq  $0x1
  40041b:	e9 d0 ff ff ff       	jmpq   4003f0 <_init+0x28>

0000000000400420 <__gmon_start__@plt>:
  400420:	ff 25 02 0c 20 00    	jmpq   *0x200c02(%rip)        # 601028 <_GLOBAL_OFFSET_TABLE_+0x28>
  400426:	68 02 00 00 00       	pushq  $0x2
  40042b:	e9 c0 ff ff ff       	jmpq   4003f0 <_init+0x28>

Disassembly of section .text:

0000000000400430 <_start>:
  400430:	31 ed                	xor    %ebp,%ebp
  400432:	49 89 d1             	mov    %rdx,%r9
  400435:	5e                   	pop    %rsi
  400436:	48 89 e2             	mov    %rsp,%rdx
  400439:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
  40043d:	50                   	push   %rax
  40043e:	54                   	push   %rsp
  40043f:	49 c7 c0 c0 05 40 00 	mov    $0x4005c0,%r8
  400446:	48 c7 c1 50 05 40 00 	mov    $0x400550,%rcx
  40044d:	48 c7 c7 02 05 40 00 	mov    $0x400502,%rdi
  400454:	e8 b7 ff ff ff       	callq  400410 <__libc_start_main@plt>
  400459:	f4                   	hlt
  40045a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000400460 <deregister_tm_clones>:
  400460:	b8 40 10 60 00       	mov    $0x601040,%eax
  400465:	48 3d 40 10 60 00    	cmp    $0x601040,%rax
  40046b:	74 13                	je     400480 <deregister_tm_clones+0x20>
  40046d:	b8 00 00 00 00       	mov    $0x0,%eax
  400472:	48 85 c0             	test   %rax,%rax
  400475:	74 09                	je     400480 <deregister_tm_clones+0x20>
  400477:	bf 40 10 60 00       	mov    $0x601040,%edi
  40047c:	ff e0                	jmpq   *%rax
  40047e:	66 90                	xchg   %ax,%ax
  400480:	c3                   	retq
  400481:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  400486:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40048d:	00 00 00

0000000000400490 <register_tm_clones>:
  400490:	be 40 10 60 00       	mov    $0x601040,%esi
  400495:	48 81 ee 40 10 60 00 	sub    $0x601040,%rsi
  40049c:	48 89 f0             	mov    %rsi,%rax
  40049f:	48 c1 ee 3f          	shr    $0x3f,%rsi
  4004a3:	48 c1 f8 03          	sar    $0x3,%rax
  4004a7:	48 01 c6             	add    %rax,%rsi
  4004aa:	48 d1 fe             	sar    %rsi
  4004ad:	74 11                	je     4004c0 <register_tm_clones+0x30>
  4004af:	b8 00 00 00 00       	mov    $0x0,%eax
  4004b4:	48 85 c0             	test   %rax,%rax
  4004b7:	74 07                	je     4004c0 <register_tm_clones+0x30>
  4004b9:	bf 40 10 60 00       	mov    $0x601040,%edi
  4004be:	ff e0                	jmpq   *%rax
  4004c0:	c3                   	retq
  4004c1:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  4004c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4004cd:	00 00 00

00000000004004d0 <__do_global_dtors_aux>:
  4004d0:	80 3d 69 0b 20 00 00 	cmpb   $0x0,0x200b69(%rip)        # 601040 <__TMC_END__>
  4004d7:	75 17                	jne    4004f0 <__do_global_dtors_aux+0x20>
  4004d9:	55                   	push   %rbp
  4004da:	48 89 e5             	mov    %rsp,%rbp
  4004dd:	e8 7e ff ff ff       	callq  400460 <deregister_tm_clones>
  4004e2:	c6 05 57 0b 20 00 01 	movb   $0x1,0x200b57(%rip)        # 601040 <__TMC_END__>
  4004e9:	5d                   	pop    %rbp
  4004ea:	c3                   	retq
  4004eb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  4004f0:	c3                   	retq
  4004f1:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  4004f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4004fd:	00 00 00

0000000000400500 <frame_dummy>:
  400500:	eb 8e                	jmp    400490 <register_tm_clones>

0000000000400502 <main>:
  400502:	48 83 ec 18          	sub    $0x18,%rsp
  400506:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
  40050b:	be 03 00 00 00       	mov    $0x3,%esi
  400510:	bf 02 00 00 00       	mov    $0x2,%edi
  400515:	e8 26 00 00 00       	callq  400540 <multstore>
  40051a:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
  40051f:	bf d4 05 40 00       	mov    $0x4005d4,%edi
  400524:	b8 00 00 00 00       	mov    $0x0,%eax
  400529:	e8 d2 fe ff ff       	callq  400400 <printf@plt>
  40052e:	b8 00 00 00 00       	mov    $0x0,%eax
  400533:	48 83 c4 18          	add    $0x18,%rsp
  400537:	c3                   	retq

0000000000400538 <mult2>:
  400538:	48 89 f8             	mov    %rdi,%rax
  40053b:	48 0f af c6          	imul   %rsi,%rax
  40053f:	c3                   	retq

0000000000400540 <multstore>:
  400540:	53                   	push   %rbx
  400541:	48 89 d3             	mov    %rdx,%rbx
  400544:	e8 ef ff ff ff       	callq  400538 <mult2>
  400549:	48 89 03             	mov    %rax,(%rbx)
  40054c:	5b                   	pop    %rbx
  40054d:	c3                   	retq
  40054e:	66 90                	xchg   %ax,%ax

0000000000400550 <__libc_csu_init>:
  400550:	41 57                	push   %r15
  400552:	41 89 ff             	mov    %edi,%r15d
  400555:	41 56                	push   %r14
  400557:	49 89 f6             	mov    %rsi,%r14
  40055a:	41 55                	push   %r13
  40055c:	49 89 d5             	mov    %rdx,%r13
  40055f:	41 54                	push   %r12
  400561:	4c 8d 25 b0 08 20 00 	lea    0x2008b0(%rip),%r12        # 600e18 <__frame_dummy_init_array_entry>
  400568:	55                   	push   %rbp
  400569:	48 8d 2d b0 08 20 00 	lea    0x2008b0(%rip),%rbp        # 600e20 <__init_array_end>
  400570:	53                   	push   %rbx
  400571:	4c 29 e5             	sub    %r12,%rbp
  400574:	31 db                	xor    %ebx,%ebx
  400576:	48 c1 fd 03          	sar    $0x3,%rbp
  40057a:	48 83 ec 08          	sub    $0x8,%rsp
  40057e:	e8 45 fe ff ff       	callq  4003c8 <_init>
  400583:	48 85 ed             	test   %rbp,%rbp
  400586:	74 1e                	je     4005a6 <__libc_csu_init+0x56>
  400588:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40058f:	00
  400590:	4c 89 ea             	mov    %r13,%rdx
  400593:	4c 89 f6             	mov    %r14,%rsi
  400596:	44 89 ff             	mov    %r15d,%edi
  400599:	41 ff 14 dc          	callq  *(%r12,%rbx,8)
  40059d:	48 83 c3 01          	add    $0x1,%rbx
  4005a1:	48 39 eb             	cmp    %rbp,%rbx
  4005a4:	75 ea                	jne    400590 <__libc_csu_init+0x40>
  4005a6:	48 83 c4 08          	add    $0x8,%rsp
  4005aa:	5b                   	pop    %rbx
  4005ab:	5d                   	pop    %rbp
  4005ac:	41 5c                	pop    %r12
  4005ae:	41 5d                	pop    %r13
  4005b0:	41 5e                	pop    %r14
  4005b2:	41 5f                	pop    %r15
  4005b4:	c3                   	retq
  4005b5:	90                   	nop
  4005b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4005bd:	00 00 00

00000000004005c0 <__libc_csu_fini>:
  4005c0:	f3 c3                	repz retq

Disassembly of section .fini:

00000000004005c4 <_fini>:
  4005c4:	48 83 ec 08          	sub    $0x8,%rsp
  4005c8:	48 83 c4 08          	add    $0x8,%rsp
  4005cc:	c3                   	retq
```

### 关于格式的注释

所有以"."开头的行都是指导汇编器和链接器工作的伪指令。我们通常可以忽略这些行。

## 访问信息

一个 x86-64 的中央处理单元（CPU）包含一组16个存储在64位值的 `通用目的寄存器`

这些寄存器用来存储整数数据和指针

### 操作数指示符

大多数指令有一个或多个`操作数`，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置

各种不同的**操作数**可能被分为三种类型：

1. **立即型**：用来表示常数值。在ATT格式的汇编代码中，立即数的书写方式是“$”后面跟一个用标准C表示法表示的整数。

2. **寄存器：**表示某个寄存器的内容，16个寄存器的低位1字节、2字节、4字节或8字节中的一个作为操作数，这些字节数分别对应于8位、16位、32位或64位。

   用符号 $r_a$ 来表示任意寄存器 a

   用引用R[$r_a$]来表示他的值

3. **内存引用：**它会根据计算出来的地址（通常称为有效地址）访问某个内存位置。

   用符号 $M_b[Addr]$ 表示对存储在内存中从地址 $Addr$ 开始对 $b$ 个字节值的引用，为了简便，我们通常省去下标$b$。

#### 寻址模式

有多种不同的`寻址模式`，允许不同形式的内存引用

语法 $Imm(r_b,r_a,s)$ 表示的是最常用的形式。

这样的引用有四个部分组成：

1. **立即偏移数 Imm**

2. **基址寄存器$r_b$**，必须是64位寄存器

3. **变值寄存器$r_a$**，必须是64位寄存器

4. **一个比例因子 $s$ **,这里的s必须是1、2、4、8

   有效地址被计算为 $Imm + R[r_b] + R[r_i]·s$

#### 练习题3.1

| 操作数         | 值    |
| -------------- | ----- |
| %rax           | 0x100 |
| 0x104          | 0xAB  |
| $0x108         | 0x108 |
| (%rax)         | 0xFF  |
| 4($rax)        | 0xAB  |
| 9(%rax,%rdx)   | 0x11  |
| 260(%rcx,%rdx) | 0x13  |
| 0xFC(,%rcx,4)  | 0xFF  |
| (%rax,%rdx,4)  | 0x11  |

### 数据传送指令

许多不同的指令划分为`指令类`，每一类中的指令执行相同的操作，只不过操作数大小不同

#### MOV类

这些指令把数据从原位置复制到目的位置，不做任何变化。

MOV类由四条指令组成：

| 指令            | 效果   | 描述           |
| --------------- | ------ | -------------- |
| MOV        S，D | D <- S | 传送           |
| movb            |        | 传送字节       |
| movw            |        | 传送字         |
| movl            |        | 传送双字       |
| movq            |        | 传送四字       |
| movabsq    I,R  | R <- I | 传送绝对的四字 |

源操作数指定的是一个 **立即数**，存储在寄存器中或者内存中。

目的操作数指定一个位置，要么是一个寄存器，要么是一个内存地址

> x86-64加了一条限制，传送指令的两个操作数不能都指向内存位置

#### MOVZ类

MOVZ类中的指令把目的地中剩余的字节填充为0

| 指令             | 效果             | 描述                         |
| ---------------- | ---------------- | ---------------------------- |
| MOVz        S，R | R <- 零扩展（S） | 以零扩展进行传送             |
| movzbw           |                  | 将做了零扩展的字节传送到字   |
| movzbl           |                  | 将做了零扩展的字节传送到双字 |
| movzwl           |                  | 将做了零扩展的字传送到双字   |
| movbq            |                  | 将做了零扩展的字节传送到四字 |
| movzwq           |                  | 将做了零扩展的字传送到四字   |

#### MOVS类

MOVS类中的指令通过符号扩展来填充，把源操作的最高位进行复制

| 指令       | 效果                     | 描述                           |
| ---------- | ------------------------ | ------------------------------ |
| MOVS  S，R | R <- 符号扩展（S）       | 传送符号扩展的字节             |
| movsbw     |                          | 将做了符号扩展的字节传送到字   |
| movsbl     |                          | 将做了符号扩展的字节传输到双字 |
| movswl     |                          | 将做了符号扩展的字传送到双字   |
| movsbq     |                          | 将做了符号扩展的字节传送到四字 |
| movswq     |                          | 将做了符号扩展的字传送到四字   |
| movslq     |                          | 将做了符号扩展的双字传送到四字 |
| cltq       | %rax <- 符号扩展（%eax） | 把%eax符号扩展到%rax           |

> 没条指令名字的最后两个字符都是大小指示符：第一个字符指定源的大小，而第二个指明目的地的大小

​                                                                                                                                                            









