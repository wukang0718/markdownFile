## 第二章-信息的表示和处理

三种重要的数字表示：

**无符号（unsigned）**编码基于传统的二进制表示法，表示大于或者等于0的数字

**补码** 编码是表示有符号整数最常见的方式，有符号整数就是可以为正或者为负的数字。

**浮点数** 编码是表示实数的科学记数法的以2为基数的版本。

----

整数的表示虽然只能编码一个相对较小的数值范围，但是这种表示是精确的。

而浮点数虽然可以编码一个较大的数值范围，但是这种表示只是近似的。

## 信息存储

大多数计算机使用8位的块，或者字节，作为最小的可寻址的内存单位，而不是访问内存中单独的位

**程序对象**：程序数据、指令和控制信息。

每个程序对象都可以简单的视为一个字节块，而程序本身就是一个字节序列

### 十六进制表示法

十六进制（简写为“hex”），使用数字0～9以及字符A～F来表示16个可能的值。

在C语言中，以0x或者0X开头的数字常量，被认为是16进制的值

##### 练习题2.1

A

```
0X39A7F8
3      9    A    7     F    8
0011 1001  1010  0111 1111 1000
```

B

```
1100 1001 0111 1011
C     9    7    B
0xC97b
```

C

```
0xD5E4c
D      5     E     4     C
1101  0101  1110  0100  1100
```

D

```
0010    0110    1110  0111   1011   0101
2       6         E    7       B     5
0X26E7B5
```

##### 练习题2.2

| n             | 2^n(十进制) | 2^n(十六进制)            |
| ------------- | ----------- | ------------------------ |
| 9             | 512         | 0x200                    |
| 19            | 524288      | 19 = 3 + 4*4 = 0x80000   |
| 14            | 16384       | 14 = 2 + 3*4 = 0x4000    |
| 0  + 4*4 = 16 | 65536       | 0x10000                  |
| 17            | 131072      | 17 = 1 + 4 * 4 = 0x20000 |
| 5             | 32          | 5 = 1 + 4 *  1 = 0x20    |
| 3 + 4 * 1 = 7 | 128         | 0x80                     |

##### 练习题2.3 

> 10进制先转16进制在转2进制

| 十进制             | 二进制    | 十六进制 |
| ------------------ | --------- | -------- |
| 0                  | 0000 0000 | 0x00     |
| 167                | 1010 0111 | 0xA7     |
| 62                 | 0011 1110 | 0x3E     |
| 188                | 1011 1100 | 0xBC     |
| 16 *3 + 7 = 55     | 0011 0111 | 0x37     |
| 16 * 8 + 8 = 136   | 1000 1000 | 0x88     |
| 16 * 15 + 3 = 243  | 1111 0011 | 0xF3     |
| 16 * 5 + 2 = 82    | 0101 0010 | 0x52     |
| 16 * 10 + 12 = 172 | 1010 1100 | 0xAC     |
| 16 * 14 + 7 = 231  | 1110 0111 | 0xE7     |

##### 练习题2.4

A

```
0x503c + 0x8 = 0x5044
```

B

```
0x503c - 0x40 = 0x4FFc 
```

C

```
0x503c + 64 = 0x503c + 0x40 = 0x507c
```

D

```
0x50ea - 0x503c = 0xAE
```

### 字数据大小

字长决定的最重要的系统参数就是虚拟地址空间的最大大小。

对于一个字长为 w 位的机器而言，虚拟地址的范围就是 0 ~ 2^w -  1，程序最多访问 2^w 个字节。

我们将程序称为“32位程序”或“64位程序”时，区别在于该程序是如何编译的，而不是运行的机器类型。

大部分的数据类型都编码位有符号数值，除非有前缀关键字 `unsigned` 或对确定大小的数据类型使用了特定的无符号声明。

### 寻址和字节顺序

多字节对象在都被存储位连续的字节序列，对象的地址为所使用字节中最小的地址。

一个 w 位的整数，其位表示为 [x<sub>w-1</sub>, w<sub>w-2</sub>, ..., x<sub>1</sub>,x<sub>0</sub>]，其中 X<sub>w-1</sub>为最高有效位，x<sub>0</sub> 为最低有效位。

假设 w 是 8 的倍数，那么最高有效字节就包含[x<sub>w-1</sub>,x<sub>w-2</sub>,...x<sub>w-8</sub>]，最低有效字节就包括[x<sub>7</sub>,x<sub>6</sub>,...x<sub>0</sub>]。

在内存中按照从最低有效字节到最高有效字节的顺序存储对象的方式，称为 **小端法**。

按照从最高有效字节到最低有效字节的顺序存储对象的方式，称为 **大端法**。

> Android和iOS只能运行小端法

取地址运算符 `&` 会创建一个指针

`sizeof(T)` 返回存储一个  T 的对象所需要的字节数。

##### 练习题2.5

```
0x87654321
小端法表示 21  43  65  87
大端法表示 87  65  43  21
```

|      | 小端法   | 大端法   |
| ---- | -------- | -------- |
| A    | 21       | 87       |
| B    | 21 43    | 87 65    |
| C    | 21 43 65 | 87 65 43 |

##### 练习题2.6

A

```
0       0    3    5    9    1    4    1
0000  0000  0011 0101 1001 0001 0100 0001
4     A    5    6    4    5    0    4
0100 1010 0101 0110 0100 0101 0000 0100
```

B

```
00000000001101011001000101000001
  01001010010101100100010100000100
21位相同
```

C

整数中除了最高位 `1` 其他的都在浮点数中包括。

浮点数会有一些非 `0` 的高位不与整数相匹配。

```
整数去掉高位的0：1101011001000101000001
除了最高位的1，其他的都在浮点数中包括了
浮点数中非0的高位： 10010100  这部分和整数不相匹配
```

### 表示字符串

C语言中字符串被编码为一个以 `null` （其值为0）字符结尾的字符数组。

终止字符的十六进制表示为 `0x00`

**Unicode** 使用32位来表示字符，每个字符要占用4个字节。

**UTF8** 将每个字节编码为一个字节序列

所有的 `ASCII` 字节序列用 `ASCII` 码表示和用 `UTF8` 表示是一样的。

##### 练习题2.7

strlen 函数不包括终止字符

```
61  62  63  64  65   66 
```

### 表示代码

二进制代码是不兼容的，二进制代码很少在不同机器和操作系统之间移植。

从机器的角度来看，程序仅仅只是字节序列。机器没有关于原始源程序的任何信息

### 布尔代数简介

1. 布尔运算 `~` 对应逻辑运算 `NOT` ，对表达式取反
2. 布尔运算 `&` 对应逻辑运算 `AND` ，当运算符两侧都为真（1），表达式为真（1）
3. 布尔元算 `|` 对应逻辑运算 `OR`，当运算两侧有一个为真（1），表达式为真（1）
4. 布尔运算 `^` 对应逻辑运算 `异或`，当运算两侧有一个为真（1），并且两个不同时为真（1），表达式结果为真（1）

##### 练习题2.8

| 运算 | 结果       |
| ---- | ---------- |
| a    | [01101001] |
| b    | [01010101] |
| ~a   | [10010110] |
| ~b   | [10101010] |
| a&b  | [01000001] |
| a\|b | [01111101] |
| a^b  | [00111100] |

**⊆**：包含于，表示一个集合中的元素全部是另一个集合里的元素。

**∈**：属于。比如，a∈A表示元素a属于集合A

**∩**：交集。比如，A∩B表示既在集合A中又在集合B中的所有元素组成的集合

**∪**:并集。比如，A∪B表示集合A和集合B中所有元素组成的集合

布尔运算 `|` 和 `&` 对应集合的交和并，`～` 对应集合的补

##### 练习题2.9

A

| 颜色               | 补                 |
| ------------------ | ------------------ |
| 黑色 { 0, 0, 0 }   | { 1, 1, 1 } 白色   |
| 蓝色 { 0, 0, 1 }   | { 1, 1, 0 } 黄色   |
| 绿色 { 0, 1, 0 }   | { 1, 0, 1 } 红紫色 |
| 蓝绿色 { 0, 1, 1 } | { 1, 0, 0 } 红色   |
| 红色 { 1, 0, 0 }   | { 0, 1, 1 } 蓝绿色 |
| 红紫色 { 1, 0, 1 } | { 0, 1, 0 } 绿色   |
| 黄色 { 1, 1, 0 }   | { 0, 0, 1 } 蓝色   |
| 白色 { 1, 1, 1 }   | { 0, 0, 0 } 黑色   |

B

```
蓝色 { 0, 0, 1 }  |  绿色 { 0, 1, 0 } = { 0, 1, 1 } 蓝绿色
黄色 { 1, 1, 0 }  &  蓝绿色 { 0, 1, 1 } = { 0, 1, 0 } 绿色
红色 { 1, 0, 0 }  ^  红紫色 { 1, 0, 1 } = { 0, 0, 1 } 蓝色
```

> 对于任一位向量a,有a^a = 0

##### 练习题2.10

| 步骤   | *x              | *y               |
| ------ | --------------- | ---------------- |
| 初始   | a               | b                |
| 第一步 | a               | a ^ b            |
| 第二步 | a ^ (a ^ b) = b | a ^ b            |
| 第三步 | b               | b ^ ( a^ b ) = a |

##### 练习题2.11

A

k, k

B

因为 a[k] ^ a[k] = 0;

C

```c
void reverse_array(int a[], int cnt)
{
  int first, last;
  for (first = 0, last = cnt - 1; first < last; first++, last--)
  {
    inplace_swap(&a[first], &a[last]);
  }
}
```

##### 练习题2.12

A

```c
x & 0xFF
```

B

> 任何数字^0 都是本身，任何数字^1都是取二进制取反

```c
x^~0xFF
```

C

```c
x | 0xFF
```

##### 练习题2.13

```
bool_or: bis(x, y);
boor_xor: x^y=(x&~y)|(~x&y)
```

[x^y=(x&~y)|(~x&y)](https://www.zhihu.com/question/20224242)

#### C语言中的逻辑运算

C语言还提供了一组逻辑运算符 `||` 、 `&&` 、 `!` ，他们返回 `1` 或 `0` ，分别表示结果为 `TRUE` 或 `FALSE`

##### 练习题2.14

| 表达式     | 值                                                           |
| ---------- | ------------------------------------------------------------ |
| x & y      | 0x66 & 0x39 = [ 0110 0110 ] & [ 0011 1001 ] = [ 0010 0000 ] = 0x20 |
| x \| y     | 0x66 \| 0x39 = [ 0110 0110 ] \| [ 0011 1001 ] = [ 0111 1111 ] = 0x7F |
| ~x \| ~y   | ~0x66 \| ~0x39 = ~[ 0110 0110 ] \| ~[ 0011 1001 ] = [ 1001 1001 ] \| [ 1100 0110 ] = [ 1101 1111 ] = 0xDF |
| x & !y     | 0x66 & !0x39 = 0x66 & 0x00 = [ 0110 0110 ] & [ 0000 0000 ] = [0000 0000] = 0x00 |
| x && y     | 0x66 && 0x39 = 0x01                                          |
| x \|\| y   | 0x66 \|\| 0x39 = 0x01                                        |
| !x \|\| !y | !0x66 \|\| !0x39 = 0x00 \|\| 0x00 = 0x00                     |
| x && ~y    | 0x66 && ~0x39 = 0x01                                         |

##### 练习题2.15

```c
#include <stdio.h>

int equal(int x, int y)
{
  // 当两个值相等的时候 ^ 结果是0
  return !(x ^ y);
}

int main()
{
  printf("%d", equal(2, 1));
  printf("\n");
  printf("%d", equal(2, 2));
}
```

#### C语言中的移位运算

##### 左移运算

C表达式 `x << k` 会把 `x` 向左移动 `k` 位，丢弃最高的 `k` 位，并在右端补 `k` 个 `0`

##### 逻辑右移

丢弃右边的 `k` 位，在左边补 `k` 个 `0`

##### 算数右移

丢弃右边的 `k` 位，在左边补 `k` 个 `x 的最高有效位` ，他对符号的整数数据运算非常有用

> 移位运算是可结合的，所以 `x << j << k` 等价于 `(x << j) << k`

> 几乎所有的编译器/机器组合都对有符号数使用算数右移
>
> 对于无符号数，右移必须是逻辑右移
>
> Java中 `x >> y` 表示算数右移，`x >>> y` 表示逻辑右移

##### 位移中 k >= w位

实际上的位移量是通过 `k mod(取模/取余) w` 得到的

##### 练习题2.16

| x        |           | x << 3    |          | x >> 2(逻辑) |          | x << 2 (算数) |          |
| -------- | --------- | --------- | -------- | ------------ | -------- | ------------- | -------- |
| 十六进制 | 二进制    | 二进制    | 十六进制 | 二进制       | 十六进制 | 二进制        | 十六进制 |
| 0xC3     | 1100 0011 | 0001 1000 | 0x18     | 0011 0000    | 0x30     | 1111 0000     | 0xF0     |
| 0x75     | 0111 0101 | 1010 1000 | 0xA8     | 0001 1101    | 0x1D     | 0001 1101     | 0x1D     |
| 0x87     | 1000 0111 | 0011 1000 | 0x38     | 0010 0001    | 0x21     | 1110 0001     | 0xE1     |
| 0x66     | 0110 0110 | 0011 0000 | 0x30     | 0001 1001    | 0x19     | 0001 1001     | 0x19     |

## 整数表示

#### 无符号数的编码   

无符号的二进制表示有一个很重要的属性，也就是每个介于 $0～2^w-1$ 之间的数都有唯一一个w位的值编码

**原理：**无符号编码的唯一性

函数 $B2U_w$ 是一个双射。

数学术语 `双射` 是指一个函数 $f$ 有两面：他将数值 x 映射为数值 y，即 $y = f(x)$，但它也可以进行反向操作，因为对每一个 $y$ 而言们都有唯一一个数值 $x$ 似的 $f(x) = y$。

函数 $ B2U_w $ （二进制到无符号数）将一个长度为 $w$ 位的位向量都映射为 $ 0～2^w-1 $ 之间的一个唯一值，反过来

函数 $ U2B_w $ （无符号数到二进制）将 $ 0～2^w-1 $ 之间的每个整数都可以映射为一个长度为 $w$ 的位模式。

#### 补码编码

对于很多应用，我们还希望表示负数。最常见的有符号的计算机表示方式就是 `补码` 形式。

##### 补码编码的定义

最高有效位 $x_{w-1}$ 也称为符号位，他的“权重”为 $-2^{w-1}$ 

符号位被设置为 $1$ 时，表示值为负，而当设置为 $0$ 时，值为非负。

补码能表示的最小值位向量是 $[1,0,0...0]$ ，其整数值为 $ TMin_w \approx -2^{w-1} $，

最大值位向量是 $[0,1,1,1...1]$，其整数值为 $TMax_w \approx \sum_{i=0}^{w-2} 2^i = 2^{w-1} - 1 $

$B2T_w$ 是一个从长度 $w$ 的位模式到 $TMin_w$ 和 $TMax_w$ 之间数字的映射，写作 $B2T_w$

补码编码具有唯一性

函数 $B2T_w$ 是一个双射, $T2B_w$ （补码到二进制）作为 $B2T_w$ 的反函数

也就是对于每个数 $x$，满足 $TMin_w \leq x \leq TMax_w$ ，则 $ T2B_w(x) $ 是 $x$ 的（唯一的）$w$ 位模式。

##### 练习题2.17

| $\vec{x}$ |        | $B2U_4(\vec{x})$             | $B2T_4(\vec{x})$                |
| --------- | ------ | ---------------------------- | ------------------------------- |
| 十六进制  | 二进制 |                              |                                 |
| 0xE       | 1110   | $1*2^3+1*2^2+1*2^1+0*2^0=14$ | $(-1*2^3)+1*2^2+1*2^1+1*2^0=-2$ |
| 0x0       | 0000   | 0                            | 0                               |
| 0x5       | 0101   | $0+2^2+0+1=5$                | $-0+2^2+0+1=5$                  |
| 0x8       | 1000   | $2^3=8$                      | $-2^3=-8$                       |
| 0xD       | 1101   | $2^3+2^2+1=13$               | $-2^3+2^2+1=-3$                 |
| 0xF       | 1111   | $2^3+2^2+2^1+1=15$           | $-2^3+2^2+2^1+1=-1$             |

1. 补码能表示的正数比负数少一个
2. 最大的无符号数值刚好比补码的最大值的两倍大一点

#### 反码

**反码：**除了最高有效位的权是 $-(2^{w-1} -1)$，而不是 $ -2^{w-1} $，它和补码是一样的
$$
B2O_w(\vec{x}) \approx -x_{w-1}(2^{w-1} - 1) + \sum_{i=0}^{w-2}x_i2^i
$$

#### 原码

**原码：**最高有效位是符号位，用来确定剩下的位应该取负权还是正权
$$
B2S_w(\vec(x)) \approx (-1)x_{w-1} * (\sum_{i=0}^{w-2}x_i2^i)
$$

##### 练习题2.18

| 十六进制            | 十进制               |
| ------------------- | -------------------- |
| 0x2e0 = 0x000002e0  | $2*16^2+14*16 = 736$ |
| -ox58 = -0x00000058 | $-(5*16+8)=-88$      |
| 0x28 = 0x00000028   | $2*16+8=40$          |
| -0x30 = -0x00000030 | $-(3*16)=-48$        |
| 0x78 = 0x00000078   | $7*16+8=120$         |
| 0x88 = 0x00000088   | $8*16+8=136$         |
| 0x1f8 = 0x000001f8  | $16^2+15*16+8=504$   |
| 0x8                 | $8$                  |
| 0xc0 = 0x000000c0   | $12*16=192$          |
| -0x48 = -0x00000048 | $-(4*16+8)=-72$      |

### 有符号数和无符号数之间的转换

将函数 $ T2U_w $ 定义为 $ T2U_w(x) \approx B2U_w(T2B_w(x)) $ 这个函数输入是一个 $ TMin_w ～ TMax_w $ 的数，结果得到一个 $ 0～UMax_w $ 的值，这里两个值有相同的位模式，除了参数是以补码表示的，而结果是无符号的。

对于 $ 0～UMax_w $ 之间的值 $ x $，定义函数 $ U2T_w $ 为 $ U2T_w(x) \approx B2T_w(U2B_2(x)) $，生成一个数字，这个数的补码表示和 $x$ 的无符号表示相同。

##### 练习题2.19

| $x$  | $ T2U_4(x) $                   |
| ---- | ------------------------------ |
| -8   | -8 + 0 = [1000] = 8 = -8 + 16  |
| -3   | -8 + 5 = [1101] = 13 = -3 + 16 |
| -2   | -8 + 6 = [1110] = 14 = -2 + 16 |
| -1   | -8 + 7 = [1111] = 15 = -1 + 16 |
| 0    | 0 = 0                          |
| 5    | [0101] = 5 = 5                 |

#### 补码转换为无符号数

对满足 $TMin_w \leq x \geq TMax_w$ 的 $x$ 有：
$$
T2U_w(x) = 
\begin{cases}
x + 2^w, x < 0 \\
x, x \geq 0
\end{cases}
$$


#### 无符号数转补码

对满足 $ 0 \leq u \leq UMax_w $ 的 $u$ 有：
$$
U2T_w(u) =
\begin{cases}
u, u \leq TMax_w \\
u - 2^w, u \gt TMax_w
\end{cases}
$$
在范围 $ 0 \leq x \leq TMax_w $ 之内的值 $x$ 而言，我们得到 $ T2U_w(x) = x $ 和 $ U2T_w(x) = x $。也就是说在这个范围之内的数字都有相同的无符号和补码表示。在这个范围之外的数字，转换需要加上 $2^w$ 。

1. 最靠近0的负数映射为最大的无符号数
2. 最小的负数映射为一个刚好在补码的正数范围之外的无符号数

### c语言中的有符号数和无符号数

当执行一个运算时，如果他的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。

##### 练习题2.21

| 表达式                       | 类型   | 求值 |
| ---------------------------- | ------ | ---- |
| -2147483647-1 == 2147483648U | 无符号 | 1    |
| -2147483647-1 < 2147483647   | 有符号 | 1    |
| -2147483647-1U < 2147483647  | 无符号 | 0    |
| -2147483647-1 < -2147483647  | 有符号 | 1    |
| -2147483647-1U < -2147483647 | 无符号 | 1    |

### 扩展一个数字的位表示

1. 要将一个无符号数转换为一个更大的数据类型：只要在表示的开头添加**0**，这种运算称为 **`零扩展`**

2. 要将一个补码数字转换为一个更大的数据类型：在表示的开头添加**最高有效位的值**，这种运算称为 **`符号扩展`**

##### 练习题2.22

A
$$
[1011] = -2^3 + 2 + 1 = -8 + 2 + 1 = -5
$$

B
$$
[11011] = -2^4 + 2^3 + 2 + 1 = -16 + 8 + 2 + 1 = -5
$$

C
$$
[111011] = -2^5 + 2 ^ 4 + 2 ^ 3 + 2 + 1 = -32 + 16 + 8 + 2 + 1 = -5
$$

> (unsigned) sx 等价于 (unsigned) (int) sx，而不等价于 (unsigned) (unsigned short) sx

##### 练习题2.23

A

| w          | fun1(w)    | fun2(w)    |
| ---------- | ---------- | ---------- |
| 0x00000076 | 0x00000076 | 0x00000076 |
| 0x87654321 | 0x00000021 | 0x00000021 |
| 0x000000C9 | 0x000000C9 | 0xFFFFFFC9 |
| 0xEDCBA987 | 0x00000087 | 0xFFFFFF87 |

B

`fun1` 函数把一个无符号数字只保留最低有效字节，返回值范围 `0-255`

`fun2` 函数把一个无符号数字转成补码形式后保留最低有效字节，返回值范围 `-128~127`

### 截断数字

当将一个 $w$ 位的数截断为一个 $k$ 位数字时，我们会丢弃高 $ w-k $ 位。截断一个数字可能会改变他的值 -----  溢出的一种形式

#### 截断无符号数

$$
x^{'}=x \% 2^k
$$

#### 截断补码数值

$$
x^{'} = U2T_k(x \% 2^k)
$$

##### 练习题2.24

| 十六进制 |        | 无符号 |        | 补码   |        |
| -------- | ------ | ------ | ------ | ------ | ------ |
| 原始值   | 截断值 | 原始值 | 截断值 | 原始值 | 截断值 |
| 0        | 0      | 0      | 0      | 0      | 0      |
| 2        | 2      | 2      | 2      | 2      | 2      |
| 9        | 1      | 9      | 1      | -7     | 1      |
| B        | 3      | 11     | 3      | -5     | 3      |
| F        | 7      | 15     | 7      | -1     | -1     |

> 在一个地方，长度参数时有符号的；而另一个地方，他又是无符号数。这样的不匹配会成为缺陷的原因，甚至会导致安全漏洞

## 整数运算

### 无符号加法

当 $ 0 \leq x, y \leq 2^w $ 时，定义运算 $ +_w^u $ 是把整数和 $x+y$ 截断为 $w$ 位得到的结果，在把这个结果看作一个无符号数
$$
x+_w^uy=
\begin{cases}
\begin{eqnarray}
& x+y,     & x + y \leq 2^w  & 正常 \\
& x+y-2^w, & 2^w \leq x + y \leq 2^{w+1} & 溢出
\end{eqnarray}
\end{cases}
$$

#### 检测无符号数加法中的溢出

$ s=x +_w^uy $，当且仅当 $s < x 或 s < y$ 时，发生了溢出。

##### 练习题2.27

```c
int uadd_ok(unsigned x, unsigned y)
{
  unsigned s = x + y; 
  return s >= x && x >= y;
}
```

#### 无符号数求反

对满足 $ 0 \leq x \lt 2^w $ 的任意 $x$，其 $w$ 位的无符号逆元 $ -_w^ux $ 由下式给出：
$$
-_w^ux = 
\begin{cases}
\begin{eqnarray}
& x, & x =0 \\
& 2^w - x, & x > 0
\end{eqnarray}
\end{cases}
$$

##### 练习题2.28

| x        |        | $-_4^ux$ |          |
| -------- | ------ | -------- | -------- |
| 十六进制 | 十进制 | 十进制   | 十六进制 |
| 0        | 0      | 0        | 0        |
| 5        | 5      | 11       | B        |
| 8        | 8      | 8        | 8        |
| D        | 13     | 3        | 3        |
| F        | 15     | 1        | 1        |

### 补码加法

对满足 $ -2^{W-2} \leq x, y \leq 2^{w-1} - 1 $ 的整数 $x$ 和 $y$ ，有：
$$
x + _w^t y = 
\begin{cases}
\begin{eqnarray}
& x + y - 2^w, & 2^{w-1} \leq x + y \\
& x + y, & -2^{w-1} \leq x + y \leq 2^{w-1} \\
& x + y + 2^w, & x + y \leq 2^{w-1}
\end{eqnarray}
\end{cases}
$$

1. 当 $x+y$ 超过 $TMax_w$ 时，就是发生了正溢出，截断的结果是从和数中减去 $2^w$
2. 当 $ x + y $ 小于 $TMin_w$ 时，就是发生了负溢出，截断的结果是把和数加上 $2^w$

#### 检测补码加法中的溢出

1. 当且仅当 $ x \gt 0, y \gt 0$ 时，但是 $ s \leq 0 $ 时，计算 $s$ 发生了正溢出
2. 当且仅当 $ x \lt 0, y \lt 0 $ 时，但是 $ s \geq 0 $ 时，计算 $s$ 发生了负溢出

#### 练习题2.29

$2^5=32$

| x             | y             | $x+y$          | $x +_5^t y$   | 情况        |
| ------------- | ------------- | -------------- | ------------- | ----------- |
| [10100] = -12 | [10001] = -15 | [100101] = -27 | [00101] = 5   | -27 + 32  1 |
| [11000] = -8  | [11000] = -8  | [110000] = -16 | [10000] = -16 | 2           |
| [10111] = -9  | [01000] = 8   | [111111] = -1  | [11111] = -1  | 2           |
| [00010] = 2   | [00101] = 5   | [000111] = 7   | [00111] = 7   | 3           |
| [01100] = 12  | [00100] = 4   | [010000] = 16  | [10000] = -16 | -16 + 32 4  |

#### 练习题2.30

```c
int tadd_ok(int x, int y)
{
	int s = x + y;
  if (x < 0 && y < 0 && s >=0)
  {
    return 0;
  }
  if (x > 0 && y > 0 && s <= 0)
  {
    return 0;
  }
  return 1;
}
```

#### 练习题2.31

无论加法是否溢出，$(x+y)-y$ 总会得到 $x$ 。

#### 练习题2.32

$y=TMin_w$ 时，$-y=Tmin_W$

在函数的测试过程中，$TMin_w$ 应该作为一个测试情况

### 补码的非

对满足 $TMin_w \leq x \leq TMax_w$ 的$x$ ，其补码的非 $-_w^tx$ 由下式给出：
$$
-_w^tx = 
\begin{cases}
\begin{eqnarray}
& TMin_w, & x = TMin_w \\
& -x, & x > TMin_w
\end{eqnarray}
\end{cases}
$$

#### 练习题2.33

| x        |             | $-_4^tx$ |          |
| -------- | ----------- | -------- | -------- |
| 十六进制 | 十进制      | 十进制   | 十六进制 |
| 0        | 0           | 0        | 0        |
| 5        | [0101] = 5  | -5       | B        |
| 8        | [1000] = -8 | -8       | 8        |
| D        | [1101] = -3 | 3        | 3        |
| F        | [1111] = -1 | 1        | 1        |

#### 补码非的位级表示

1. 对每一位取补，在对结果加1

```
[0101] 5   ~[0101] = [1010] = -6 + 1 = [1011] = -5
```

2. 将位向量分为两部分的基础之上，假设 **k是最右边1的位置**，对 k 位左边的所有位取反

```
[0101] 5    [101 1] = -5
```

### 无符号乘法

> 将一个无符号数截断为 $w$ 位等价于计算该值模 $2^w$

对满足 $ 0 \leq x, y \leq UMax_w$ 的 $x$ 和 $y$ 有：
$$
x *_w^uy = (x * y) mod 2^w
$$

### 补码乘法

> 将一个补码数截断位 $w$ 位相当于先计算该值模 $2^w$ ，在把无符号数转换为补码

对满足 $TMin_w \leq x, y \leq TMax_w$ 的 $x$ 和 $y$ 来说，有：
$$
x * _w^t y = U2T_w((x*y) mod 2^w)
$$

> 无符号数和补码乘法的位级等价性

##### 练习题2.34

| 模式        | x        | y        | x*y         | 截断的x*y |
| ----------- | -------- | -------- | ----------- | --------- |
| 无符号 补码 | [100]  4 | [101] 5  | 20 [010100] | [100] 4   |
| 补码        | [100] -4 | [101] -3 | 12 [001100] | [100] -4  |
| 无符号      | [010]  2 | [111]  7 | 14 [001110] | [110] 6   |
| 补码        | [010] 2  | [111] -1 | -2 [111110] | [110] -2  |
| 无符号      | [110]  6 | [110] 6  | 36 [100100] | [100] 4   |
| 补码        | [110] -2 | [110] -2 | 4 [000100]  | [100] -4  |

### 乘以常数

#### 乘以2的冥

对于任何 $k \geq 0$ ，给出 $x2^k$ 的 $w+k$ 位的无符号表示，这里右边增加了$k$ 个0 

比如：当w = 4, 11 可以被表示为 [1011] ， k = 2 时，将其左移得到6位向量[101100] ，即可编码为无符号数 $ 11 * 4 = 44$; 

#### 乘以常数

由于整数乘法比移位和加法的代价要大的多，许多C语言编译器试图以移法、加法和减法的组合来消除很多整数乘以常数的情况。

比如： $x * 14$ 利用属性 $14 = 2^4 - 2^ 1$ ，将乘法重写为 $ (x << 4) - (x << 1)$ ，这时只需要两个移位和一个减法

##### 练习题2.40

| k                  | 移位 | 加法/减法 | 表达式                  |
| ------------------ | ---- | --------- | ----------------------- |
| 6 = 2^2 + 2 ^ 1    | 2    | 1         | (x << 2) + (x << 1)     |
| 31 = 2^5 - 1       | 1    | 1         | (x << 5) - x            |
| -6 = 2^1 - 2^3     | 2    | 1         | (x << 1) - (x << 3)     |
| 55 = 2^6 - 2^3 - 1 | 2    | 2         | (x << 6) - (x << 3) - x |

##### 练习题2.41

1. 当 $n = m$ 时，选择形式A，只需要移位一次
2. 当 $n = m + 1$ 时，形式A、B都可以，都需要两次移位
3. 当 $ n > m + 1 $ 时，选择形式B，只需要移位两次

### 除以2的冥

> 在大多数机器上，整数除法比整数乘法更慢

除以2的冥也可以使用移位运算来实现，只不过我们用的是右移，无符号和补码分别使用逻辑右移和算数右移

#### 除以2的次冥的无符号除法

C变量x和k有无符号数值 $x$ 和 $k$ ，且 $ 0 \leq k \lt w $ ，则C表达式 $x >>k$ 产生数值 $x/2^k$ 的**向下取整**

#### 除以2的冥的补码的除法，向下舍入

C变量x和y分别有补码值$x$ 和无符号数$k$，且 $ 0 \leq k \lt w $ ，当执行算数移位时，C表达式 $x >> k$ 产生数值 $x/2^k$ **向下取整**

#### 除以2的冥的补码的除法，向上舍入

C变量x和y分别有补码值$x$ 和无符号数$k$，且 $ 0 \leq k \lt w $ ，当执行算数移位时，C表达式 $ (x + (1 << k) -1) >> k $  产生数值 $x / 2^k$ 的**向上取整**

##### 练习题2.42

```c
int div16(int x) 
{
  int bias = (x >> 31) & 0xF;
  return (x + bias) >> 4;
}
```

##### 练习题2.43

$$
\begin{eqnarray}
& M & = 2^5-1 & = & 31 \\
& N &  = 2^3 & = & 8
\end{eqnarray}
$$

## 浮点数

浮点表示对形如 $V=x*2^y$ 的有理数进行编码

> 知道20世纪80年代，计算机制造商对浮点数，不回太多的关注运算的精确性，而把实现的速度和简便性看的比数组精确性更重要

> 大约在1985年，随着IEEE标准754的推出而改变，这是一个仔细制定的表示浮点数及其运算的标准

> **舍入**：即当一个数字不能被准确的表示为这种格式时，就必须向上调整或者向下调整

### 二进制小数

$$
b = \sum_{i=-n}^{m}2^ib_i
$$

符号`.` 现在变为了二进制的点 ，点的左边的位的权重时2的正冥，点右边的位的权重是2的负冥。

> 二进制小数点向左移动一位相当于这个数被2除
>
> 二进制小数点向右移动一位相当于这个数乘2

小数的二进制表示法只能表示哪些能够被写成 $x*2^y$ 的数。其他的值只能被近似的表示，增加二进制的长度可以提高表示的精度。

##### 练习题2.45

| 小数值             | 二进制表示 | 十进制表示 |
| ------------------ | ---------- | ---------- |
| 1/8                | 0.001      | 0.125      |
| 3/4                | 0.11       | 0.75       |
| 25/16              | 1.1001     | 1.5625     |
| 43/16              | 10.1011    | 2.6875     |
| 9/8                | 1.001      | 1.125      |
| 94/16 = 48 / 8     | 101.111    | 5.875      |
| 51/16 = 3 + (3/16) | 11.0011    | 3.1875     |

### IEEE浮点表示

IEEE浮点标准用 $ V=(-1)^s * M * 2^E $ 的形式来表示一个数
$$
100.001 = (-1) ^0 * 1.00001 * 2^2
$$

```
s = 0 
M = 1.00001
E = 2
```

- **符号（sign）** s决定这数是负数（s = 1）还是整数（s = 0），而对于数值0的符号位解释做特殊处理

- **尾数** M是一个二进制小数

  比如 `1.001101001` 中 M就是 `001101001`

- **阶码** E的作用是对浮点数加权，这个加权是2的E次冥（可能是负数）

**浮点数的位表示划分为三个字段，分别对这些值进行编码**

- 一个单独的符号位 $s$ 直接就编码符号 $s$
- k 位的阶码字段 $exp=e_{k-1}...e_1e_0$ 编码阶码E
- n位小数字段 $frac=f_{n-1}...f_1f_0$ 编码尾数M，但编码出来的值也依赖于阶码字段的值是否等于0

**浮点数两种最常见的格式**

1.  在单精度浮点格式（C语言中的float）中，$s$ 为1位、$k$ 为8位和$n$ 为23位
2. 在双精度浮点格式（C语言中的double）中，$s$ 为1位、$k$ 为11位和$n$ 为52位

![image-20210923210044062](https://gitee.com/wu_kang0718/image/raw/master//20210923210046003.png)

**根据 exp 的值，被编码的值可以分成下面三种情况**

1. **规格化：**当E的二进制位（exp）不全为0，也不全为1时。

   阶码字段被解释为以偏置形式表示的==有符号整数==。

   阶码的值是 $E=e-Bias$ ,其中 `e` 是==无符号数==，而`Bias` 是一个等于 $2^{k-1}-1$（单精度是127，双精度是1023）

   小数字段 `frac` 被解释为小数值 `f`，其中 $0\leq f \lt 1$

   尾数定义为 $M=1+f$，这种方式也被叫做 `隐含的以1开头的表示`

2. **非规格化：**当E的二进制位(exp)全为0时。

   阶码的值是 $E=1-Bias$ 

   尾数的值是 $M=f$ 

   非规格化数有两个用途：

   1. 它们提供了一种表示数值0的方法
   2. 表示那些非常接近0的小数，它们提供了一种属性，称为 `逐渐下溢` 属性

3. **特殊数值：**当E的二进制位（exp）全为1的时候为特殊数值

   当小数域（frac）全为0的时候，得到的值表示无穷

   1. 当 s = 0时，表示 +∞
   2. 当 s = 1时，表示 -∞

   > 无穷能表示溢出的结果

   当小数域（frac）全非0的时候，结果值称为 "NaN"

##### 练习题2.47

| 位      | e    | E    | $2^E$ | f    | M    | $2^E*M$ | V    | 十进制 |
| ------- | ---- | ---- | ----- | ---- | ---- | ------- | ---- | ------ |
| 0 00 00 | 0    | 0    | 1     | 0/4  | 0/4  | 0/4     | 0    | 0      |
| 0 00 01 | 0    | 0    | 1     | 1/4  | 1/4  | 1/4     | 1/4  | 0.25   |
| 0 00 10 | 0    | 0    | 1     | 2/4  | 2/4  | 2/4     | 1/2  | 0.5    |
| 0 00 11 | 0    | 0    | 1     | 3/4  | 3/4  | 3/4     | 3/4  | 0.75   |
| 0 01 00 | 1    | 0    | 1     | 0/4  | 4/4  | 4/4     | 4/4  | 1      |
| 0 01 01 | 1    | 0    | 1     | 1/4  | 5/4  | 5/4     | 5/4  | 1.25   |
| 0 01 10 | 1    | 0    | 1     | 2/4  | 6/4  | 6/4     | 3/2  | 1.5    |
| 0 01 11 | 1    | 0    | 1     | 3/4  | 7/4  | 7/4     | 7/4  | 1.75   |
| 0 10 00 | 2    | 1    | 2     | 0/4  | 4/4  | 8/4     | 8/4  | 2      |
| 0 10 01 | 2    | 1    | 2     | 1/4  | 5/4  | 10/4    | 5/2  | 2.5    |
| 0 10 10 | 2    | 1    | 2     | 2/4  | 6/4  | 12/4    | 12/4 | 3      |
| 0 10 11 | 2    | 1    | 2     | 3/4  | 7/4  | 14/4    | 7/2  | 3.5    |
| 0 11 00 | -    | -    | -     | -    | -    | -       | +∞   | -      |
| 0 11 01 | -    | -    | -     | -    | -    | -       | NaN  | -      |
| 0 11 10 | -    | -    | -     | -    | -    | -       | NaN  | -      |
| 0 11 11 | -    | -    | -     | -    | -    | -       | NaN  | -      |

##### 练习题2.48

```
0x00359141 = [0011 0101 1001 0001 0100 0001] = 1.101011001000101000001 * 2^21
E = 21
M = 1.101011001000101000001
f = 10101100100010100000100
e = 21 = 127 = 148 = 0x94 = [1001 0100]
V =          [0100 1010 0101 0110 0100 0101 0000 0100]
0x4A564504 = [0100 1010 0101 0110 0100 0101 0000 0100]
	                   001 101 0110 0100 0101 0000 01
	                   // 整数除了最高有效位1其他的都可以匹配小数
```

##### 练习题2.49

**A**

阶码部分应该是1

小数部分应该是n个0就能表示最小的整数       

在这个二进制后面在添加一个1就是不能表示的最小的整数

```
[10000...00001] 总长度是n+2
```

所以不能表示的最小整数就是
$$
2^{n+1} + 1
$$
**B**

当n = 23
$$
2^{22} + 1 = 16777216 + 1 = 16777217
$$


### 舍入

找到最接近的的匹配值，它可以用期望的浮点形式表示出来，这就是 `舍入`运算的任务

IEEE浮点格式定义了四种不同的舍入方式

1. **向偶数舍入：**也被称为`向最接近的值舍入`将数字向上或者向下舍入，使结果的最低有效数字是偶数。

   **保留位(Guard bit)、近似位(Round bit)和粘滞位(Sticky bit)**
   我们以十进制数来举例。如果我们想保留两位小数，即留下十分位和百分位上的数。

   **保留位(Guard bit)**就是结果的最低位，即百分位；

   **近似位(Round bit)**就是第一个被舍掉的位，即千分位；

   而千分位之后的所有位（包括万分位、十万分位等等）或起来构成**粘滞位(Sticky bit)**。

   **四舍六入五成双**

   **中间值**

   求中间值的方法如下：

   1. 保留位(Guard bit)和左边的数字保持不变；
   2. 近似位(Round bit)改写为N/2（N为进制数，十进制就是10，二进制就是2）
   3. 粘滞位(Sticky bit)全部写零

   > 对于这些和中间值完全相等的原始值，我们考察保留位(Guard bit)，

   1. 如果保留位是偶数，则直接舍弃近似位(Round bit)和粘滞位(Sticky bit)；
   2. 如果保留位是奇数，则先向保留位进一，之后舍弃近似位(Round bit)和粘滞位(Sticky bit)。

   这样，结果中的保留位就是偶数了

2. **向零舍入：**把正数向下舍入，把负数向上舍入

3. **向下舍入：**把正数和负数都向下舍入

4. **向上舍入：**把正数和负数都向上舍入

##### 练习题2.50

| 原值   | 中间值 | 舍入后的值                                             |
| ------ | ------ | ------------------------------------------------------ |
| 10.010 | 10.010 | 中间值和原值一样，保留位是偶数，直接舍掉其他位   10.0  |
| 10.011 | 10.010 | 原值比中间值大，向上舍入 10.1                          |
| 10.110 | 10.110 | 中间值和原值一样，保留位是偶奇数，进1舍掉其他位   11.0 |
| 11.001 | 11.010 | 原值比中间值小，向下舍入 11.0                          |

##### 联系题2.52

| 格式A    |                           | 格式B    |                                  |
| -------- | ------------------------- | -------- | -------------------------------- |
| 位       | 值                        | 位       | 值                               |
| 011 0000 | 1                         | 0111 000 | 1                                |
| 101 1110 | $\frac{15}{2}$            | 1001 111 | $\frac{15}{2}$                   |
| 010 1001 | $0.11001 = \frac{25}{32}$ | 0110 100 | $\frac{3}{4}$ ??? 为什么向下舍入 |
| 110 1111 | $\frac{31}{2}$            | 1011 000 | 16                               |
| 000 0001 | $0.000001 = \frac{1}{64}$ | 0001 000 | $\frac{1}{64}$                   |

### 浮点运算

浮点加法不具有结合性

浮点加法满足了单调性属性。无符号或补码不具有这个实数（和整数）加法的属性







