hello.c

```c
#include <stdio.h>

int main()
{
	printf(" hello world\n");
	return 0;
}
```

## 概念 

1. 源程序（hello.c）实际上就是一个由值0和值1组成的位（又称为比特）序列，8个位被组织成一组，称为字节。每个字节表示程序中的某些文本字符。
2. 像 `hello.c` 这样的只有 `ASCII` 字符构成的文件称为 `文本文件`，所有其他文件都称为 `二进制文件`。
3. 系统中所有的信息，都是由一串 `比特` 表示的。
4. 区分不同数据对象的唯一方法就是我们读到这些数据对象时的 `上下文`。
5. 为了在系统上运行 `hello.c` 的程序，每条C语句都必须被其他的程序转化为一系列的 `低级机器语言指令`，然后这些指令按照一种称为 `可执行目标程序` 的格式打好包，并以 `二进制磁盘文件` 的形式存放起来，目标程序也称为 `可执行目标文件`。
6. 在 `Unix` 系统上，从源文件到目标文件的转化是由 `编译器驱动程序` （例如之后用到的 `GCC`）完成的。

通过运行 `GCC` 程序将原文件转化为可执行文件

```bash
gcc -o hello hello.c
```

这个转换的过程需要经历四个阶段：`预处理器`、 `编译器`、 `汇编器`、 `链接器`，一起构成了`编译系统(compilation system)`。

- 预处理器（cpp）：修改了 `hello.c` 的源（程序）文本，输出 `hello.i`
- 编译器（ccl）：汇编程序（文本），输出一个 `汇编语言程序` `hello.c`
- 汇编器（as）：输出可重定位目标文件（二进制） `hello.o`
- 链接器（ld）：链接 `printf.o` 输出可执行目标程序（二进制）`hello`

### 系统的硬件组成

1. **总线**：贯穿整个系统的一组电子管道，称为 `总线`，他携带信息字节，并负责在各个部件间传递。通常总线被设计为传送 `定长的字节块，也就是字（word）`，字中的字节数（字长）是一个基本的系统参数。
2. **I/O设备**：I/O（输入/输出）设备是系统与外部世界的联系通道。每个I/O设备都通过一个 `控制器` 或 `适配器` 与I/O总线相连，在I/O主线和I/O设备之间传递信息。

- 控制器：是 **I/O 设备本身**或者**系统的主印制电路板（主板）**上的芯片组
- 适配器：是一块**插在主板插槽上的卡**

3. **主存**：主存是一个临时储存设备，在处理器执行程序时，用来存放程序和程序处理的数据。

   从物理上来说：主存是由一组 `动态随机存取存储器（DRAM）` 芯片组成的。

   从逻辑上来说：存储器是一个 `线性的` `字节数组`，每个字节都有唯一的地址（数组的索引）

4. **处理器**：中央处理单元（CPU），简称处理器，是解释（或执行）存储在主存中的`指令`的`引擎`。
   - **核心**：处理器的核心是一个**大小为一个字的储存设备（或`寄存器`）**，称为`程序计数器（PC）`。在任何时候，PC都指向主存中的某条机器语言指令（即含有该条指令的地址）。
   - 处理器的操作围绕着 `主存`、`寄存器文件（register file）`、`算数逻辑单元（ALU）` 进行。
   - 寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。
   - ALU 计算新的数据和地址值
   - CPU 在指令的要求下会执行下面的操作
     - **加载**：从主存中复制一个字节或一个字到寄存器，以覆盖寄存器原来的内容
     - **存储**：从寄存器复制一个字节或者一个字到主存中的某个位置，以覆盖主存原来的内容
     - **操作**：把两个寄存器的内容复制到 ALU 中，进行算数运算，并将结果存放到一个寄存器中，以覆盖寄存器中原来的内容。
     - **跳转**：从指令本身中抽取一个字，并将这个字复制到 程序计数器（PC）中，以覆盖PC中原来的值
   - 指令集架构：描述的是每条机器代码执行的效果
   - 微体系结构：描述的是处理器实际上是如何实现的

5. 高速缓存处理器（cache memory，简称为 cache 或高速缓存）

   作为暂时的集结区域，存放处理器近期可能会用到的信息。

   L1和L2的高速缓存是用一种叫 `静态随机访问存储器（SRAM）` 的硬件技术实现的。

   使用高速缓存，系统可以更快的访问速度，原理是：利用了高速缓存的**局部性**原理，即程序具有访问局部区域里的数据和代码的趋势。

### 操作系统管理硬件

操作系统有两个基本的功能；

1. 防止硬件被失控的应用程序滥用。
2. 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备

操作系统抽象概念：进程、虚拟内存、文件

- **文件**：文件是对I/O设备的抽象表示
- **虚拟内存**：虚拟内存是对主存和I/O设备的抽象表示
- **进程**：进程是对处理器、虚拟内存和I/O设备的抽象表示

#### 进程

进程是操作系统对正在运行的程序的一种抽象。每个进程都好像在独占的使用硬件。

`并罚运行` 就是说一个进程的指令和另一个进程的指令在交错执行。

多核处理器能同时执行多个程序

一个CPU看上去都是在并发的执行多个进程，这是通过处理器在进程间切换来实现的，操作系统实现这种交错执行的机制称为**`上下文切换`**

**上下文**：操作系统保持和跟踪进程运行所需的所有状态信息。这种状态就是 **`上下文`**，包括许多信息：比如PC和寄存器文件的当前值，以及主存的内容。

一个进程实际上可以由多个称为 `线程` 的执行单元组成，每个线程都运行在进程执行的上下文中，并共享同样的代码和全局的数据。

- 多线程比多进程之间更容易共享数据

- 线程一般来说比进程更高效

#### 虚拟内存

虚拟内存是一个抽象概念，为每个进程提供了一种假象，即每个进程都在独占使用内存。每个进程看到内存都是一致的，称为 **`虚拟地址空间`**。

![image-20210912102600457](https://gitee.com/wu_kang0718/image/raw/master//20210912102601091.png)

`堆` 和 `栈` 可以在运行时动态的扩展和收缩。

`内存虚拟地址` 是为内核保留的，不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数，相反，他们必须调用内核来执行这些操作。

#### 文件

文件就是字节序列，仅此而已。

系统中所有的输入输出都是通过使用一小组 Unix I/O的系统函数调用读写文件来实现的。

### Amdahl定律

Told: 优化之前执行整体程序所需的时间

Tnew：优化之后的整体程序执行所需的时间

𝛼：整个系统执行中可以被优化的部分

k：性能提升比例；优化之前的执行所需的时间 / 优化之后执行所需的时间 
$$
T_{new} = (1 - \alpha) * T_{old} + (\alpha * T_{old}) / k = T_{old} * [(1-\alpha) + \alpha / k]
$$

$$
\begin{eqnarray}
加速比 S & = & \frac {T_{old}} {T_{new}} \\
				& = & \frac {T_{old}} {T_{old} * [(1-\alpha) + \alpha / k]} \\
				& = & \frac {1} {(1 - \alpha) + \alpha / k}
\end{eqnarray}
$$


当k趋向于∞时，意味着，𝛼 部分的速度可以忽略不计，于是可以得到
$$
S = \frac {1} {1 - \alpha}
$$


#### 练习题1.1

##### A

```
Told = 25
跑完原来的 1500 公里需要的时间是 15小时，现在跑完这段时间是 10小时
𝛼 = 原来的时间 / 原来的总时间
𝛼 = 15 / 25 = 0.6
k = 原来的时间 / 现在的时间
k = 15 / 10 = 1.5
```

根据
$$
S = \frac {1} {(1-\alpha + \alpha/k)}
$$
得到结果
$$
\begin{eqnarray}
S & = & \frac {1} {(1 - 0.6) + 0.6 / 1.5}\\
	& = & \frac {1} {0.4 + 0.4}\\
  & = & 1.25
\end{eqnarray}
$$


##### B

$$
1.67 = \frac {1} {(1 - 0.6) + 0.6 / k} \\ \\
\begin{eqnarray}
k & = & 0.6 / \begin{pmatrix} \frac {1} {1.67} - 0.4 \end{pmatrix} \\
k & = & 0.6 / 0.2 \\
k & = & 3
\end{eqnarray} \\
$$

$$
\begin{eqnarray}
& // 现在的时间x \\
x & = & 15 / k = 5 \\
& // 现在速度 y \\
y & = & 1500 / 5 = 300
\end{eqnarray}
$$

#### 练习题1.2

$$
S = 2 \\ 
\alpha = 0.8 \\
2 = \frac {1} {0.2 + 0.8 / k} \\
k = \frac {0.8} {0.3} = 2.67
$$

### 并发和并行

**并发**：指一个同时具有多个活动的系统

**并行**：指用并发来使一个系统运行的更快

#### 线程级并发

传统意义上，这种并发这是模拟出来的，是通过一台计算机在他正在执行的线程之间快速切换来实现的。

超线程：有时称为同时多线程，是一项允许一个CPU执行多个控制流的技术

#### 指令级并发

在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为**指令级并发**。

如果处理器可以达到比一个周期一条指令更快的执行速率，就称为 **超标量处理器**。

#### 单指令、多数据并行

在最低层次上，许多现在处理拥有特殊的硬件，允许一个指令产生多个可以并行执行的操作，这种方式称为 **单指令、多数据**，即 `SIMD` 并行。

#### 抽象

抽象的使用是计算机科学中最重要的概念之一。

在处理器中，**指令集架构**提供了对实际处理器硬件的抽象。

**虚拟机** 提供了对整个计算机的抽象，包括操作系统、处理器和程序。







