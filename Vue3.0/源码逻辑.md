## ref 方法

> 源码地址：[https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/ref.ts](https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/ref.ts)

接收一个参数，返回参数的深代理，如果参数是对象，`.value` 是 `reactive` 的值

```typescript
export function ref(value?: unknown) {
  return createRef(value)
}
```

## shallowRef 方法

> 源码地址：[https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/ref.ts](https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/ref.ts)

接收一个参数，返回 对参数 浅代理

```typescript
export function shallowRef(value?: unknown) {
  return createRef(value, true)
}
```

调用 `createRef` 方法

#### createRef 方法

判断如果已经是 `ref` 对象，直接返回这个对象

否则，返回一个 `RefImpl` 类型的实例

```typescript
function createRef(rawValue: unknown, shallow = false) {
  if (isRef(rawValue)) { // 判断是否已经是 ref 对象
    return rawValue
  }
  return new RefImpl(rawValue, shallow)
}
```

#### RefImpl 类

`new` 接收两个参数

| 参数      | 描述                                            |
| --------- | ----------------------------------------------- |
| _rawValue | 原始值                                          |
| _shallow  | 是否只做浅层的代理，默认值 false 做 深层 的代理 |

实例属性：

| 属性      | 描述                                                    |
| --------- | ------------------------------------------------------- |
| _value    | 原始值                                                  |
| __v_isRef | ref 对象的表示，在判断对象是不是 ref 对象的时候，会用到 |
| _rawValue | 原始值 或 修改后的原始值                                |
| _shallow  | 是否只做浅层的监听                                      |
| value     | 暴露给外层访问的属性，会调用 get、set 方法              |

```typescript
class RefImpl<T> {
  private _value: T

  public readonly __v_isRef = true

  constructor(private _rawValue: T, public readonly _shallow = false) {
    this._value = _shallow ? _rawValue : convert(_rawValue) // convert 函数做深层的代理
  }

  get value() {
    track(toRaw(this), TrackOpTypes.GET, 'value') // track 函数收集依赖，后续描述
    return this._value
  }

  set value(newVal) {
    // hasChanged 方法会对 NaN 做处理
    if (hasChanged(toRaw(newVal), this._rawValue)) { // 如果修改后的值，和当前值不一致
      this._rawValue = newVal
      this._value = this._shallow ? newVal : convert(newVal)
      trigger(toRaw(this), TriggerOpTypes.SET, 'value', newVal) // trigger 函数触发依赖，后续描述
    }
  }
}
```

#### convert 函数

接收一个参数，如果参数是`对象/数组`类型，调用 reactive 方法，否则返回参数本身

```typescript
const convert = <T extends unknown>(val: T): T =>
  isObject(val) ? reactive(val) : val
```

## isRef 方法

> 源码位置： [https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/ref.ts](https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/ref.ts)

方法接收一个参数，返回 `boolean`，判断参数是不是 `ref` 类型

```typescript
export function isRef(r: any): r is Ref {
  return Boolean(r && r.__v_isRef === true)
}
```

## triggerRef 方法

> 源码位置： [https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/ref.ts](https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/ref.ts)

方法接收一个 `ref` 对象，触发这个 `ref` 对象上收集的依赖

```typescript
export function triggerRef(ref: Ref) {
  trigger(toRaw(ref), TriggerOpTypes.SET, 'value', __DEV__ ? ref.value : void 0)
}
```

## unref 方法

> 源码位置： [https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/ref.ts](https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/ref.ts)

方法接收一个参数，如果参数是 `ref` 类型，返回 `.value` 的值，否则返回参数自己

```typescript
export function unref<T>(ref: T): T extends Ref<infer V> ? V : T {
  return isRef(ref) ? (ref.value as any) : ref
}
```



## toRaw 方法

> 源码位置： [https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/reactive.ts](https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/reactive.ts)

方法接收一个参数，如果参数是 `reactive` 对象会返回 `reactive` 对象的原始值，如果不是 `reactive` 对象，就返回接收的参数

`ReactiveFlags.RAW` 在 `reactive` 对象的 `get` 方法中做了处理 

```typescript
export function toRaw<T>(observed: T): T {
  return (
    (observed && toRaw((observed as Target)[ReactiveFlags.RAW])) || observed
  )
}
```



## track 方法

收集依赖

```typescript
export function track(target: object, type: TrackOpTypes, key: unknown) {
  if (!shouldTrack || activeEffect === undefined) {
    return
  }
  let depsMap = targetMap.get(target)
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()))
  }
  let dep = depsMap.get(key)
  if (!dep) {
    depsMap.set(key, (dep = new Set()))
  }
  if (!dep.has(activeEffect)) {
    dep.add(activeEffect)
    activeEffect.deps.push(dep)
    // 开发环境才会执行，方便追踪依赖调试，忽略
    if (__DEV__ && activeEffect.options.onTrack) {
      activeEffect.options.onTrack({
        effect: activeEffect,
        target,
        type,
        key
      })
    }
  }
}
```



















